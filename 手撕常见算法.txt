###二叉树
##遍历
public Class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;
	public TreeNode() {
	}
	public TreeNode(int val) {
		this.val = val;
	}
}

#前中后遍历-递归
List<Ingeter> res = new ArrayList<>();

public void pre(TreeNode root) {
	if (root == null) {
		return;
	}
	res.add(root.val);
	pre(root.left);
	pre(root.right);
}

public void in(TreeNode root) {
	if (root == null) {
		return;
	}
	pre(root.left);
	res.add(root.val);
	pre(root.right);
}

public void post(TreeNode root) {
	if (root == null) {
		return;
	}
	pre(root.left);
	pre(root.right);
	res.add(root.val);
}

#前中后遍历-迭代
public void pre(TreeNode root) {
	if (root == null) {
		return;
	}
	Stack<TreeNode> stack = new Stack<>();
	stack.push(root);
	while (!stack.isEmpty()) {
		TreeNode cur = stack.pop();
		res.add(cur.val);
		if (cur.right != null) stack.push(cur.right);
		if (cur.left!= null) stack.push(cur.left);
	}
}

public void in(TreeNode root) {
	if (root == null) {
		return;
	}
	Stack<TreeNode> stack = new Stack<>();
	TreeNode cur = root;
	while (cur != null || !stack.isEmpty()) {
		if (cur != null) {
			stack.push(cur);
			cur = cur.left;
		}
		cur = stack.pop();
		res.add(cur.val);
		cur = cur.right;
	}
}

public void post(TreeNode root) {
	if (root == null) {
		return;
	}
	Stack<TreeNode> stack = new Stack<>();
	stack.push(root);
	while (!stack.isEmpty()) {
		TreeNode cur = stack.pop();
		// 处理的顺序为中右左，反过来刚好为后序
		res.add(cur.val);
		if (cur.left!= null) stack.push(cur.left);
		if (cur.right != null) stack.push(cur.right);
	}
	Collections.reverse(res);
}

#层序遍历
public void sequence(TreeNode root) {
	if (root == null) {
		return;
	}
	LinkedList<TreeNode> queue = new LinkedList<>();
	queue.add(root);
	while (!queue.isEmpty()) {
		LinkedList<TreeNode> tmp = new LinkedList<>();
		for (TreeNode cur : queue) {
			if (cur.left!= null) tmp.add(cur.left);
			if (cur.right != null) tmp.add(cur.right);
			res.add(cur.val);
		}
		queue = tmp;
	}
}

##合并两个二叉树
public TreeNode merge(TreeNode rootA, TreeNode rootB) {
	if (rootA == null) {
		return rootB;
	}
	if (rootB == null) {
		return rootA;
	}
	TreeNode root = new TreeNode(rootA.val + rootB.val);
	root.left = merge(rootA.left, rootB.left);
	root.right = merge(rootA.right, rootB.right);
	return root;
}

###数组
##合并两个有序数组
public void merge(int[] nums1, int m, int[] nums2, int n) {
	int i = m - 1, j = n - 1, k = i + j - 1;
	while (i >= 0 && j >= 0) {
		nums1[k--] = (nums1[i] > nums2[j]) ? nums1[i--] : nums2[j--];
	}
	while (j >= 0) {
		nums1[k--] = nums2[j--];
	}
}

###链表
public Class Node {
	int val;
	Node next;
	public Node() {
	}
	public Node(int val) {
		this.val = val;
	}
}
##合并两个有序链表
#递归
public Node merge(Node headA, Node headB) {
	if (headA == null) {
		return headB;
	}
	if (headB == null) {
		return headA;
	}
	if (headA.val < headB.val) {
		headA.next = merge(headA.next, headB);
		return headA;
	} else {
		headB.next = merge(headA, headB.next);
		return headB;
	}
}
#迭代
public Node merge(Node headA, Node headB) {
	Node dummy = new Node(-1);
	Node cur = dummy;
	Node curA = headA, curB = headB;
	while (curA != null && curB != null) {
		if (curA.val < curB.val) {
			cur.next = curA;
			curA = curA.next;
		} else {
			cur.next = curB;
			curB = curB.next;
		}
		cur = cur.next;
	}
	cur.next = curA == null ? curB : curA;	
	return dummy.next;
}
##反转链表
public Node reverse(Node head) {
	Node cur = head, pre = null;
	while (cur != null) {
		Node tmp = cur.next;
		cur.next = pre;
		pre = cur;
		cur = tmp;
	}
	return pre;
}
##获取链表中间节点
public Node getMid(Node head) {
	if (head == null) {
		return null;
	}
	Node slow = head, fast = head;
	while (fast != null && fast.next != null) {
		slow = slow.next;
		fast = fast.next.next;
	}
	return slow; // 中间偏右
}
##是否有环
public boolean getMid(Node head) {
	if (head == null) {
		return null;
	}
	Node slow = head, fast = head;
	while (fast != null && fast.next != null) {
		slow = slow.next;
		fast = fast.next.next;
		if (slow == fast) {
			return true;
		}
	}
	return false;
}
##环的入口
public Node getMid(Node head) {
	if (head == null) {
		return null;
	}
	Node slow = head, fast = head;
	while (fast != null && fast.next != null) {
		slow = slow.next;
		fast = fast.next.next;
		if (slow == fast) {
			Node tmp = head;
			while (tmp != slow) {
				tmp = tmp.next;
				slow = slow.next;
			}
			return slow;
		}
	}
	return null;
}
##是否回文链表
#eg: 1,2,3,2,1
Node front;

public boolean isPalindrome(Node head) {
	front = head;
	return dfs(head);
}

public boolean dfs(Node head) {
	if (head == null) {
		return true;
	}
	// 递归到最后一个节点
	if (!dfs(head)) {
		return false;
	}
	if (head.val != front.val) {
		return false;
	}
	front = front.next;
	return true;
}
##链表相交
public Node getInsectionNode(Node headA, Node headB) {
	if (headA == null || headB == null) {
		return null;
	}
	Node curA = headA, curB = headB;
	while (curA != curB) {
		curA = curA == null ? headB : curA.next;
		curB = curB == null ? headA : curB.next;
	}
	return curA;
}
##链表奇偶下标移动一起
#eg 1,2,3,4,5 -> 1,3,5,2,4
public Node removeOddAndEven(Node head) {
	if (head == null) {
		return null;
	}
	Node odd = head;
	Node evenHead = head.next;
	Node even = evenHead;
	while (even != null && even.next != null) {
		odd.next = even.next;
		odd = odd.next;
		even.next = odd.next;
		even = even.next;
	}
	odd.next = evenHead;
	return head;
}

###排序
public void swap(int[] nums, int i, int j) {
	int tmp = nums[i];
	nums[i] = nums[j];
	nums[j] = tmp;
}
##冒泡
public void bubbleSort(int[] nums) {
	int n = nums.length - 1;
	for (int i = 0; i < n - 1; i++) {
		boolean isSwapped = false;
		for (int j = 0; j < n - 1 - i; j++) {
			if (nums[j] > nums[j + 1]) {
				swap(nums, i, j);
				isSwapped = true;
			}
		}
		if (!isSwapped) {
			break;
		}
	}
}
##选择排序
public void selectionSort(int[] nums) {
	int n = nums.length - 1;
	for (int i = 0; i < n - 1; i++) {
		int minIndex = i;
		for (int j = i + 1; j < n; j++) {
			if (nums[j] < nums[minIndex]) {
				minIndex = j;
			}
		}
		swap(nums, i, minIndex);
	}
}
##插入排序
public void insertionSort(int[] nums) { // i表示未插入的牌，j表示已插入的牌
	int n = nums.length - 1;
	for (int i = 1; i < n; i++) {
		int key = nums[i];
		int j = i - 1;
		while (j >= 0) {
			if (nums[j] > key) {
				nums[j + 1] = nums[j];// 后移
			} else {
				break;
			}
			j++;
		}
		nums[j + 1] = key;
	}
}
##快排
public void quickSort(int[] nums) {
	quick(nums, 0, nums.length - 1);
}

private void quickSort(int[] nums, int low, int high) {
	if (low >= high) {
		return;
	}
	int pivot = partition(nums, low, high);
	quickSort(nums, low, pivot - 1);
	quickSort(nums, pivot + 1, high);
}

private int partition(int[] nums, int low, int high) {
	int pivotValue = nums[high];
	int left = low, right = high - 1;
	while (left <= right) {
		while (left <= right && nums[left] <= pivotValue) {
			left++;
		}
		while (left <= right && nums[right] >= pivotValue) {
			right--;
		}
		if (left < right) {
			swap(nums, left, right);
		}
	}
	nums[left] = pivotValue;
	nums[high] = nums[left];
	return left;
}


###二分查找
public int search(int[] nums, int target) {
	int l = 0;
	int r = nums.length - 1;
	while (l <= r) {
		int mid = l + (r - l) / 2;// 防止下标过大，直接相加溢出
		if (nums[mid] == target) {
			return mid;
		} else if (nums[mid] < target) {
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}
	return -1;
}

###二分查找第一个和最后一个
public int searchFirst(int[] nums, int target) {
	int l = 0;
	int r = nums.length - 1;
	while (l <= r) {
		int mid = l + (r - l) / 2;// 防止下标过大，直接相加溢出
		if (nums[mid] == target) {
			r = mid - 1;
		} else if (nums[mid] < target) {
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}
	return l > nums.length - 1 ? -1 : l;
}

public int searchLast(int[] nums, int target) {
	int l = 0;
	int r = nums.length - 1;
	while (l <= r) {
		int mid = l + (r - l) / 2;// 防止下标过大，直接相加溢出
		if (nums[mid] == target) {
			l = mid + 1;
		} else if (nums[mid] < target) {
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}
	return r < 0 ? -1 : r;
}

public int[] search(int[] nums, int target) {
	int l = 0;
	int r = nums.length - 1;
	int first = -1, last = -1;
    while (l <= r) {
		int mid = l + (r - l) / 2;// 防止下标过大，直接相加溢出
		if (nums[mid] == target) {
			fisrt = mid;
			r = mid - 1;
		} else if (nums[mid] < target) {
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}
	while (l <= r) {
		int mid = l + (r - l) / 2;// 防止下标过大，直接相加溢出
		if (nums[mid] == target) {
			last = mid;
			l = mid + 1;
		} else if (nums[mid] < target) {
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}
	return new int[]{fisrt, last};
}

###双指针
##接雨水
public int getDrops(int[] height) {
	int res = 0;
	int left = 0, right = height.length - 1;
	int maxLeft = 0, maxRight = 0;
	while (left < right) {
		maxLeft = Math.max(maxLeft, height[left]);
		maxRight = Math.max(maxRight, height[right]);
		if (maxLeft < maxRight) {
			res += maxLeft - height[left];
			left ++;
		} else {
			res += maxRight - height[right];
			right ++;
		}
	}
}

##盛最多的水
public int maxArea(int[] height) {
	int res = 0;
	int left = 0, right = height.length - 1;
	while (left < right) {
		int curArea = Math.min(height[left], height[right]) * (right - left);
		res = Math.max(res, curArea);
		if (height[left] < height[right]) {
			left++;
		} else {
			right--;
		}
	}
	return res;
}

##判断回文字符串
public boolean isPalindrome(String str) {
	if (str == null) {
		return false;
	}
	int left = 0, right = str.length() - 1;
	while (left < right) {
		if (str.charAt(left++) != str.charAt(right--)) {
			return false;
		}
	}
	return true;
}

###滑窗
##无重复的最长字串
public int lengthOfSubstring(String str) {
	int res = 0;
	if (str == null) {
		return res;
	}
	Set<Character> set = new HashSet<>();
	int left = 0, right = 0;
	while (right < str.length()) {
		char cur = str.charAt(right);
		while(set.contains(cur)) {
			set.remove(str.charAt(left));
			left++;
		}
		set.add(cur);
		res = Math.max(res, set.size());
		// res = Math.max(res, right - left + 1);
		right++;
	}
}

###动态规划
##最大子数组和
##eg：[-2,1,-3,4,-1,2,1,-5,4]，[4,-1,2,1]最大，和为6
public int maxSubArraySum(int[] nums) {
	// 假设某个函数是必须以数组中某个元素结尾的最大子数组和
	int n = nums.length;
	int[] dp = new int[n];
	f[0] = nums[0];
	int res = f[0];
	for (int i = 1; i < n; i++) {
		dp[i] = dp[i - 1] < 0 ? nums[i] : dp[i - 1] + nums[i];
		res = Math.max(res, dp[i]);
	}
	return res;
}

##爬楼梯
##要么爬一步，要么爬两步
public int maxMethods(int n) { 
	if (n < 1) return 0;
	if (n = 1) return 1;
	if (n = 2) return 2;
	int[] dp = new int[n + 1];
	dp[1] = 1;
	dp[2] = 2;
	for (int i = 3; i <= n; i++) {
		dp[i] = dp[i - 1] + dp[i - 2];
	}
	return dp[n];
}
public int maxMethods(int n) { 
	if (n < 1) {
		return 0;
	}
	int a = 0;
	int b = 0;
	int res = 1;
	for (int i = 1; i <= n; i++) {
		// 简单理解：a是上上次的值，b是上次的值
		a = b;
		b = res;
		res = a + b;
	}
	return res;
}

###数组中第k个最大元素
##eg: [3,2,1,5,6,4], k = 2, 输出5；[3,2,3,1,2,4,5,5,6], k = 4, 输出4
##关键在于理解题目，第k个最大元素，也就是排序后的nums[nums.length - k];
##涉及到排序，假如考虑快排
publie int findKthLargest(int[] nums, int k) {
	// 结合二分查找，有序就直接二分查找，无序mid就替换为partition
	int left = 0, right = nums.length - 1, targetIndex = nums.length - k;
	while (left <= right) {
		int pivot = partition(nums, left, right);
		if (pivot == targetIndex) {
			return pivot;
		} else if (pivot < targetIndex) {
			left = pivot + 1;
		} else {
			right = pivot - 1;
		}
	}
	return -1;
}
// 分区方法和之前保持一致，记住某个模板，遇到变种直接改
private int partition(int[] nums, int low, int high) {
	int pivotValue = nums[high];
	int left = low, right = high - 1;
	while (left <= right) {
		while (left <= right && nums[left] <= pivotValue) {
			left++;
		}
		while (left <= right && nums[right] >= pivotValue) {
			right--;
		}
		if (left < right) {
			swap(nums, left, right);
		}
	}
	nums[left] = pivotValue;
	nums[high] = nums[left];
	return left;
}

